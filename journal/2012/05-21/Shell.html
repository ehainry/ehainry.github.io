<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<title>Shell and programming paradigms [velsheda]</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../../css/bootstrap.min.css" rel="stylesheet">
<link href="../../css/plus.css" rel="stylesheet">
<link rel="stylesheet" href="../../css/pygments.css" type="text/css" media="screen, projection" />
<link rel="icon" type="image/png" href="/icon.png" />
<meta name="author" content="EH" />
</head>
<body>
<nav class="navbar navbar-inverse navbar-static-top" role="navigation">
<div class="container">
<div class="navbar-header">
<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#menu-c">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
<a class="navbar-brand" href="/journal/index.html">Velsheda</a>
</div>
<div class="collapse navbar-collapse" id="menu-c">
<ul class="nav navbar-nav">
<li><a href="/journal/archive.html">Archive</a></li>
<li><a href="/journal/categories.html">Categories</a></li>
<li><a href="/journal/about.html">Contact</a></li>
<li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Links</a>
<ul class="dropdown-menu">
	<li><a href="https://bitbucket.org/manu">Bitbucket</a></li>
	<li><a href="http://www.goodreads.com/user/show/2385793">Goodreads</a></li>
	<li><a href="http://last.fm/">Last.fm</a></li>
	<li><a href="https://linuxfr.org/">DLFP</a></li>
</ul></li>
</ul>
</div>
</div>
</nav>
<div class="container-fluid">
<div class="row">
<div class="col-sm-10">
 <h2>Shell and programming paradigms</h2>
 <!--<span id="tag">en</span>-->
 <span id="tag">
   
   <a href="/journal/categories.html#en">en</a>,
   </span>
 <p>The shell is usually the interface through which the user communicates with applications and files (graphically as in Gnome Shell or textually as with bash for example). It is quite important to be able to compose the activities. In bash composing essentially means using pipes to use the output of a program as the input of another one.</p>

<p>Let us illustrate how important this concept is with two citations:</p>

<blockquote>
<p>A long time ago, the original neckbeards decided that it was a good idea to chain together small programs that each performed a specific task, and that the universal interface between them should be text.</p>

<p>Ted Dziuba <a href='http://teddziuba.com/2011/10/node-js-is-cancer.html'>http://teddziuba.com/2011/10/node-js-is-cancer.html</a></p>
</blockquote>

<blockquote>
<p>Text streams are a valuable universal format because they&#8217;re easy for human beings to read, write, and edit without specialized tools. These formats are (or can be designed to be) transparent.</p>

<p><a href='http://catb.org/~esr/writings/taoup/html/textualitychapter.html'>http://catb.org/~esr/writings/taoup/html/textualitychapter.html</a> Eric S. Raymond in <em>The Art of Unix Programming</em></p>
</blockquote>

<p>However text is quickly problematic when data is structured: the formatting in columns for human reading is not the best when you want to select a given column and the width is not consistent or some cells can be empty). So composing commands often goes through some text plumbing (making commands such as <code>vipe</code> terribly useful. Also, the scripting language associated with shells can be quite painful to use (inconsistency: <code>fi</code> ends if statements but <code>done</code> for while and for).</p>

<p>To account for that latter problem, two approaches have been tried:</p>

<ul>
<li>Creating a shell with a coherent language: <a href='http://fishshell.com/'>fish</a></li>

<li>Using a shell rooted into already put to test languages: python for <a href='http://ipython.org/'>ipython</a>, perl for <a href='http://www.pardus.nl/projects/zoidberg/'>zoidberg</a>&#8230;</li>
</ul>

<p>For the former problem, having a better programming language mitigates the problem but does not solve it. ipython has an interesting way of putting output data in structured tables for intelligent grepping and cutting. Other projects solve it in their own way and explore what a modern shell can be <em>e.g.</em> <a href='http://acko.net/blog/on-termkit/'>termkit</a>, <a href='http://code.google.com/p/hotwire-shell/'>hotwire</a> or powershell.</p>

<h2 id='object_or_typed_shell'>Object or typed Shell</h2>

<p>Powershell is probably the first to have ventured in what an object shell can be. This makes it possible to have pipelines such as:</p>

<pre><code>Get-ChildItem C:\Scripts | Where-Object {$_.Length -gt 200KB} | Sort-Object Length</code></pre>

<p><code>Get-ChildItem</code> lists the content of a directory (like <code>dir</code> or <code>ls</code>). The result has a length attributes on which it is possible to filter or to sort.</p>

<p>Obviously, commands need to be rewritten, to expose an API, to define the equality of objects, which attributes are comparable and how&#8230;</p>

<p>ipython achieves the same effect but may be used with normal commands as it tries to be smart in interpreting what a tabular output means.</p>

<p>I began implementing my own shell programmed in lua (I already did a C one as a student project years ago) with the objective of having typed answers. Some choices:</p>

<ul>
<li>output of commands is a table of hashtables (the only structure in lua)</li>

<li>to get stdout, it goes through a generic pretty-printer</li>

<li>in a linux system, ps is no more work than ls, as ps is just a specific exploration of <code>/proc</code>.</li>
</ul>

<h2 id='rdbm_shell'>RDBM Shell</h2>

<p>Grepping is a selection. Cutting (and analogous awk commands) is projection. Sorting is sorting. Join, combine are joins.</p>

<p>A shell could very well be controlled as a Relational Database.</p>

<h2 id='functional_shell'>Functional Shell</h2>

<p>shell is curryfied! Aliases are partial evaluations. Why should shell not be functional?</p>

<p>Type of commands:</p>

<ul>
<li><code>cd: path -&gt; ()</code></li>

<li><code>ls: Maybe path -&gt; [[infos]]</code></li>
</ul>

<p>Type of command separators:</p>

<ul>
<li>
<p><code>;: (&#39;a -&gt; &#39;c) -&gt; (() -&gt; &#39;c) -&gt; &#39;a -&gt; &#39;c</code></p>

<p><code>;</code> is probably what Haskell&#8217;s <code>&gt;&gt;</code> stands for.</p>
</li>

<li>
<p><code>pipe: (&#39;a -&gt; &#39;b) -&gt; (&#39;b -&gt; &#39;c) -&gt; &#39;a -&gt; &#39;c</code></p>

<p>pipe is composition of commands: in haskell, pipe would be written <code>&gt;&gt;=</code></p>
</li>
</ul>

<p>This is better detailed in <a href='http://okmij.org/ftp/Computation/monadic-shell.html'>UNIX Pipes as IO Monads</a>.</p>

<p>But shell is essentially variadic, which is not a functional trait. Look at the signature of <code>zip</code>or <code>tar</code> for example:</p>

<pre><code>	zip: path -&gt; path -&gt; path -&gt; path ... -&gt; path -&gt; ()</code></pre>

<p>Or logically <code>zip: path -&gt; [path] -&gt; ()</code>.</p>
<div class="date">Écrit le 21 May 2012 par <a href="https://plus.google.com/103784259248105086753?rel=author">Emmanuel</a></div>
</div>
<div class="col-sm-2">
  <a href="/journal/index.html">Index</a><br />
  Next: <a href="/journal/2012/09-08/epub_couleur.html">ePub en couleurs</a><br />
  Prev: <a href="/journal/2012/05-04/No_DRM_Day.html">Journée contre les DRM</a><br />
</div>
</div>
</div>
<script src="../../js/jquery.min.js"></script>
<script src="../../js/bootstrap.min.js"></script>
</body>
</html>
